create database data_warehouse ;
USE DATA_WAREHOUSE ;

SHOW TABLES;

-- Analyze how a sales evolves over time 

SELECT 
YEAR(ORDER_DATE ) AS YEAR  , 
SUM(SALES_AMOUNT) AS TOTAL_SALES ,
SUM(QUANTITY) AS TOTAL_QUANTITY ,
COUNT(DISTINCT ORDER_NUMBER) AS ORDER_NO
FROM `GOLD.FACT_SALES`
WHERE ORDER_DATE IS NOT NULL
GROUP BY YEAR
ORDER BY YEAR ;


-- Calculate the total sales per month and the running tptal of sales over time 

SELECT DATE_FORMAT(ORDER_DATE , '%y-%m') AS MONTH ,
SUM(SALES_AMOUNT) AS MONTHLY_SALE ,
SUM(SUM(SALES_AMOUNT)) OVER(ORDER BY DATE_FORMAT(ORDER_DATE , '%y-%m'))AS CUMULATIVE_MONTHLY_SALE
FROM `GOLD.FACT_SALES`
WHERE ORDER_DATE IS NOT NULL
GROUP BY MONTH
ORDER BY MONTH;


-- Analyze the yearly performance of the products by comparing each products sale to both 
--  its average sales performance and previous year sales performance

WITH PRODUCT_YEARLY_SALE AS (
SELECT S.PRODUCT_KEY ,
P.PRODUCT_NAME ,
YEAR(S.ORDER_DATE) AS SALES_YEAR ,
SUM(S.SALES_AMOUNT) AS YEARLY_SALES   
FROM `GOLD.FACT_SALES` AS S
JOIN `GOLD.DIM_PRODUCTS` AS P ON 
 S.PRODUCT_KEY = P.PRODUCT_KEY
 GROUP BY  S.PRODUCT_KEY ,
P.PRODUCT_NAME ,
YEAR(S.ORDER_DATE)),

AVG_AND_PREVIOUS_YEAR_SALES  AS(
SELECT 
PRODUCT_KEY , PRODUCT_NAME , SALES_YEAR , YEARLY_SALES ,
AVG(YEARLY_SALES) OVER(PARTITION BY PRODUCT_KEY) AS AVG_YEARLY_SALES ,
LAG(YEARLY_SALES) OVER (PARTITION BY PRODUCT_KEY ORDER BY SALES_YEAR) AS PREVIOUS_YEAR_SALE
FROM PRODUCT_YEARLY_SALE )

SELECT 
PRODUCT_KEY , PRODUCT_NAME , SALES_YEAR , YEARLY_SALES , AVG_YEARLY_SALES ,PREVIOUS_YEAR_SALE ,
CASE 
WHEN YEARLY_SALES >= AVG_YEARLY_SALES THEN 'ABOVE AVG' 
ELSE 'BELOW AVG'
END AS SALES_VS_AVG
FROM AVG_AND_PREVIOUS_YEAR_SALES
ORDER BY PRODUCT_KEY , SALES_YEAR ;


-- Which category contributes the most to overall sales

SELECT P.CATEGORY ,
SUM(S.SALES_AMOUNT) AS TOTAL_SALES ,
ROUND((SUM(S.SALES_AMOUNT)/(SELECT SUM(SALES_AMOUNT) FROM `GOLD.FACT_SALES`)) * 100 , 2) AS PER_CONTRI
FROM `GOLD.FACT_SALES` AS S JOIN
`GOLD.DIM_PRODUCTS` AS P
ON S.PRODUCT_KEY = P.PRODUCT_KEY
GROUP BY P.CATEGORY
ORDER BY TOTAL_SALES DESC;


-- SEGMENT PRODUCTS INTO RANGES AND COUNT HOW MANY PRODUCTS FALL INTO EACH CATEGORY .

SELECT 
CASE 
WHEN cost < 100 THEN 'BELOW 100'
WHEN cost BETWEEN 100 AND 499 THEN '100 - 499'
WHEN cost BETWEEN 500 AND 999 THEN '500 - 999'
WHEN cost >= 1000 THEN '1000 and ABOVE'
ELSE 'UNKNOWN'
END AS cost_range,
COUNT(*) AS total_products
FROM `gold.dim_products`
GROUP BY cost_range
ORDER BY total_products DESC;


-- BUILD A CUSTOMER REPORT

SELECT C.CUSTOMER_KEY, C.FIRST_NAME,C.LAST_NAME ,C.COUNTRY,
COUNT(DISTINCT S.ORDER_NUMBER) AS TOTAL_ORDERS,
SUM(S.SALES_AMOUNT) AS TOTAL_SALES,
ROUND(AVG(S.SALES_AMOUNT), 2) AS AVG_ORDER_VALUE
FROM 
`GOLD.FACT_SALES` AS S
JOIN 
`GOLD.DIM_CUSTOMERS` AS C
ON S.CUSTOMER_KEY = C.CUSTOMER_KEY
GROUP BY 
C.CUSTOMER_KEY, C.FIRST_NAME,C.LAST_NAME , C.COUNTRY
ORDER BY 
TOTAL_SALES DESC;


-- PRODUCT PERFORMANCE REPORT

SELECT P.PRODUCT_KEY,P.PRODUCT_NAME,P.CATEGORY,P.SUBCATEGORY,
COUNT(DISTINCT S.ORDER_NUMBER) AS TOTAL_ORDERS,
SUM(S.QUANTITY) AS TOTAL_QUANTITY_SOLD,
SUM(S.SALES_AMOUNT) AS TOTAL_SALES,
ROUND(SUM(S.SALES_AMOUNT) / NULLIF(SUM(S.QUANTITY), 0), 0) AS AVG_SELLING_PRICE
FROM 
`GOLD.FACT_SALES` AS S
JOIN 
`GOLD.DIM_PRODUCTS` AS P
ON S.PRODUCT_KEY = P.PRODUCT_KEY
GROUP BY P.PRODUCT_KEY,P.PRODUCT_NAME,P.CATEGORY,P.SUBCATEGORY
ORDER BY TOTAL_SALES DESC;
 
 























